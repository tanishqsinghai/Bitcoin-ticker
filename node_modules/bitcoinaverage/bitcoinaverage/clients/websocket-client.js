'use strict';

var config = require('../config');
var common = require('../common');
var WS = require('ws');
var restfulClient = require('./restful-client');


module.exports = {
  WebsocketClient: function (publicKey) {
    this.publicKey = publicKey;
    this.websocket = null;

    this.connect = function (url, subscriptionMessage, callbackHandlerFunction, errorHandler, closeHandler) {
      console.log('connecting...');
      var restClient = restfulClient.RestfulClient(this.publicKey);
      var that = this;
      restClient.getTicket(function (response) {
        var ticket = JSON.parse(response)['ticket'];
        var wsUrl = url + '?public_key=' + publicKey + '&ticket=' + ticket;
        that.websocket = new WS(wsUrl);

        that.websocket.onmessage = function (msg) {
          var res = JSON.parse(msg.data);
          callbackHandlerFunction(res);
        };

        that.websocket.onopen = function () {
          console.log('opening');
          var msg = JSON.stringify(subscriptionMessage);
          that.websocket.send(msg);
        };

        that.websocket.onerror = function (err) {
          if (errorHandler) {
            errorHandler(err)
          } else {
            console.log("BA websocket error");
            console.log(err);
          }
        };

        that.websocket.onclose = function (data) {
          if (closeHandler) {
            closeHandler(data);
          } else {
            console.log("BA websocket closed");
            console.log(data);
          }
        };
      }, function (err) {
        console.log(err);
      });
    };

    this.connectNew = function (wsVersion, url, subscriptionMessage, callbackHandlerFunction, errorHandler, closeHandler, errorTicketHandler) {
      var versionUrls = {
        'v2': config.BASE_URL_V2,
        'v3': config.BASE_URL_V3
      };
      var ticketUrl = versionUrls[wsVersion] + 'get_ticket';
      var that = this;
      common.getResourceForFullUrl(ticketUrl, this.publicKey, function (response) {
        var ticket = JSON.parse(response)['ticket'];
        var wsUrl = url + '?public_key=' + that.publicKey + '&ticket=' + ticket;
        that.websocket = new WS(wsUrl);

        that.websocket.onmessage = function (msg) {
          var res = JSON.parse(msg.data);
          callbackHandlerFunction(res);
        };

        that.websocket.onopen = function () {

          var msg = JSON.stringify(subscriptionMessage);
          that.websocket.send(msg);
        };

        that.websocket.onerror = function (err) {
          if (errorHandler) {
            errorHandler(err)
          } else {
            console.log("BA websocket error " + wsVersion);
            console.log(err);
          }
        };

        that.websocket.onclose = function (data) {
          if (closeHandler) {
            closeHandler(data);
          } else {
            console.log("BA websocket closed " + wsVersion);
            console.log(data);
          }
        };
      }, errorTicketHandler);
    };

    this.connectV2 = function (url, subscriptionMessage, callbackHandlerFunction, errorHandler, closeHandler, errorTicketHandler) {
      this.connectNew('v2', url, subscriptionMessage, callbackHandlerFunction, errorHandler, closeHandler, errorTicketHandler);
    };

    this.connectV3 = function (url, subscriptionMessage, callbackHandlerFunction, errorHandler, closeHandler, errorTicketHandler) {
      this.connectNew('v3', url, subscriptionMessage, callbackHandlerFunction, errorHandler, closeHandler, errorTicketHandler);
    };

    /**
     * Connects to BitcoinAverage websocket that provides orderbook data
     * @param exchange - the exchange to receive orderbook data from
     * @param symbols - list of symbols for which to receive orderbook data
     * @param handleResponseCallback - successful response callback
     * @param errorHandler - error callback
     * @param closeHandler - socket closed callback
     * @param errorTicketHandler - ticket creation error callback
     */
    this.connectToOrderbookWebsocket = function (exchange, symbols, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler) {
      var wsUrl = config.WEBSOCKET_PREFIX_V2 + 'orderbooks';
      var subscriptionMessage = {
        "event": "message",
        "data": {
          "operation": "subscribe",
          "options": {
            "currency_list": symbols,
            "exchange": exchange
          }
        }
      };
      this.connectV2(wsUrl, subscriptionMessage, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler);
    };

    this.connectToTickerWebsocketV2 = function (symbol_set, symbols, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler) {
      var wsUrl = config.WEBSOCKET_PREFIX_V2 + 'ticker';
      var subscriptionMessage = {
        "event": "message",
        "data": {
          "operation": "subscribe",
          "options": {
            "currency_list": symbols,
            "symbol_set": symbol_set
          }
        }
      };
      this.connectV2(wsUrl, subscriptionMessage, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler);
    };

    this.connectToExchangeWebsocketV2 = function (exchange_list, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler) {
      var wsUrl = config.WEBSOCKET_PREFIX_V2 + 'exchanges';
      var subscriptionMessage = {
        "event": "message",
        "data": {
          "operation": "subscribe",
          "options": {
            "exchange_list": exchange_list
          }
        }
      };
      this.connectV2(wsUrl, subscriptionMessage, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler);
    };

    this.connectToTickerWebsocketV3 = function (market, symbols, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler) {
      var wsUrl = config.WEBSOCKET_PREFIX_V3 + 'stream';
      var subscriptionMessage = {
        "event": "message",
        "data": {
          "operation": "subscribe",
          "options": {
            "symbol_set": market,
            "currency_list": symbols
          },
          "channel": "multiple-ticker"
        }
      };
      this.connectV3(wsUrl, subscriptionMessage, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler);
    };

    this.connectToExchangeWebsocketV3 = function (exchangeName, symbols, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler) {
      var wsUrl = config.WEBSOCKET_PREFIX_V3 + 'stream';
      var subscriptionMessage = {
        "event": "message",
        "data": {
          "operation": "subscribe",
          "options": {
            "exchange": exchangeName,
            "currency_list": symbols
          },
          "channel": "multiple-exchanges"
        }
      };
      this.connectV3(wsUrl, subscriptionMessage, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler);
    };

    /**
     * Connects to BitcoinAverage websocket that provides trade data
     * @param exchange - the exchange to receive trade data from
     * @param symbols - list of symbols for which to receive trade data
     * @param handleResponseCallback - successful response callback
     * @param errorHandler - error callback
     * @param closeHandler - socket closed callback
     * @param errorTicketHandler - ticket creation error callback
     */
    this.connectToOrderbookWebsocketV3 = function (exchange, symbols, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler) {
      var wsUrl = config.WEBSOCKET_PREFIX_V3 + 'stream';
      var subscriptionMessage = {
        "event": "message",
        "data": {
          "operation": "subscribe",
          "options": {
            "currency_list": symbols,
            "exchange": exchange
          },
          "channel": "orderbooks"
        }
      };
      this.connectV3(wsUrl, subscriptionMessage, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler);
    };

    /**
     * Connects to BitcoinAverage websocket that provides trade data
     * @param exchange - the exchange to receive trade data from
     * @param symbols - list of symbols for which to receive trade data
     * @param handleResponseCallback - successful response callback
     * @param errorHandler - error callback
     * @param closeHandler - socket closed callback
     * @param errorTicketHandler - ticket creation error callback
     */
    this.connectToTradesWebsocketV3 = function (exchange, symbols, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler) {
      var wsUrl = config.WEBSOCKET_PREFIX_V3 + 'stream';
      var subscriptionMessage = {
        "event": "message",
        "data": {
          "operation": "subscribe",
          "options": {
            "currency_list": symbols,
            "exchange": exchange
          },
          "channel": "tradebooks"
        }
      };
      this.connectV3(wsUrl, subscriptionMessage, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler);
    };


    /**
     * Connects to BitcoinAverage websocket that provides trade data
     * @param exchange - the exchange to receive trade data from
     * @param symbols - list of symbols for which to receive trade data
     * @param handleResponseCallback - successful response callback
     * @param errorHandler - error callback
     * @param closeHandler - socket closed callback
     * @param errorTicketHandler - ticket creation error callback
     */
    this.connectToTradesWebsocket = function (exchange, symbols, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler) {
      var wsUrl = config.WEBSOCKET_PREFIX_V2 + 'trades';
      var subscriptionMessage = {
        "event": "message",
        "data": {
          "operation": "subscribe",
          "options": {
            "currency_list": symbols,
            "exchange": exchange
          }
        }
      };
      this.connectV2(wsUrl, subscriptionMessage, handleResponseCallback, errorHandler, closeHandler, errorTicketHandler);
    };


    /**
     * Connects to the websocket which gives ticker data for the specified market and symbol.
     * Override received_message() for custom usage.
     * @param market - local or global
     * @param symbol - crypto-fiat pair (example BTCUSD)
     * @param handleResponseCallback - function which handles the received response message from the socket
     * @param errorHandler - handles error events
     * @param closeHandler - handles close events
     */
    this.connectToTickerWebsocket = function (market, symbol, handleResponseCallback, errorHandler, closeHandler) {
      var wsUrl = config.WEBSOCKET_PREFIX + 'ticker';
      var subscriptionMessage = {
        "event": "message",
        "data": {
          "operation": "subscribe",
          "options": {
            "currency": symbol,
            "market": market
          }
        }
      };
      this.connect(wsUrl, subscriptionMessage, handleResponseCallback, errorHandler, closeHandler);
    };

    this.connectToMultipleTickerWebsocket = function (market, symbols, handleResponseCallback, errorHandler, closeHandler) {
      var wsUrl = config.WEBSOCKET_PREFIX + 'multiple/ticker';
      var subscriptionMessage = {
        "event": "message",
        "data": {
          "operation": "subscribe",
          "options": {
            "currency_list": symbols,
            "symbol_set": market
          }
        }
      };
      var msg = JSON.stringify(subscriptionMessage);
      this.connect(wsUrl, subscriptionMessage, handleResponseCallback, errorHandler, closeHandler);
    };

    /**
     * Connects to the websocket which gives data for the given exchange.
     * @param exchangeName - lowercase exchange name (example: kraken)
     * @param handleResponseCallback - function which handles the received response message from the socket
     * @param errorHandler - handles error events
     * @param closeHandler - handles close events
     */
    this.connectToExchangeWebsocket = function (exchangeName, handleResponseCallback, errorHandler, closeHandler) {
      var wsUrl = config.WEBSOCKET_PREFIX + 'exchanges';
      var subscriptionMessage = {
        "event": "message",
        "data": {
          "operation": "subscribe",
          "options": {
            "exchange": exchangeName
          }
        }
      };
      this.connect(wsUrl, subscriptionMessage, handleResponseCallback, errorHandler, closeHandler);
    };

    return this;
  }
};

